#!/usr/bin/perl

BEGIN {
  $ENV{MOJO_MODE} = 'production';
}

use strict;
use warnings;
use utf8;
use feature ':5.10';

# CORE MODULES:
use Encode qw(decode encode);
use File::Basename qw(fileparse);
use File::Find;
use File::Spec::Functions qw(catdir);
use FindBin qw($Bin);
use Getopt::Long qw(GetOptions);
use IO::Socket;

# Use CPAN modules installed by Carton:
use lib catdir($Bin, "local", "lib", "perl5");

# CPAN MODULES:
use Browser::Open qw(open_browser_cmd_all);
use Mojolicious::Lite;
use Mojolicious::Plugin::AccessControl;
use Mojo::IOLoop::ReadWriteFork;
use UI::Dialog;

# These dependencies have to be explicitely declared for
# application packagers like perlc or PAR.
use IO::Select; # Core module
use Pod::Simple::Transcode; # CPAN module

plugin 'AccessControl';

# Chrome unsafe ports:
my %UNSAFE_PORTS;
$UNSAFE_PORTS{2049} = "nfs";
$UNSAFE_PORTS{3659} = "apple-sasl or PasswordServer";
$UNSAFE_PORTS{4045} = "lockd";
$UNSAFE_PORTS{6000} = "X11";
$UNSAFE_PORTS{6665} = "Alternate IRC - Apple addition";
$UNSAFE_PORTS{6666} = "Alternate IRC - Apple addition";
$UNSAFE_PORTS{6667} = "Standard IRC - Apple addition";
$UNSAFE_PORTS{6668} = "Alternate IRC - Apple addition";
$UNSAFE_PORTS{6669} = "Alternate IRC - Apple addition";

print <<START;

Tabula v.0.1
Mojolicious framework for desktop applications.
START

# HELP:
if ($ARGV[0] and $ARGV[0] =~ /^--help$/) {
  help();
}

# APPLICATION LIFECYCLE VARIABLES:
my %running_scripts;
my $forbidden_requests = 0;
my $page_closed = 0;

# PORT VARIABLES:
my $start_port;
my $stop_port;
my $first_available_port = 0;

# SETTINGS:
my $browser = 'default';
my $port_setting;
my $no_port_test;

# Command-line arguments:
GetOptions(
  "browser=s" => \$browser,
  "port=s" => \$port_setting,
  "no-port-test" => \$no_port_test
);

unless (defined $port_setting) {
  $start_port = 3000;
  $stop_port = 9000;
}

if (defined $port_setting) {
  if ($port_setting =~ '-') {
    if (defined $no_port_test) {
      print "Port ranges are not allowed if the --no-port-test option is in use!\n\n";
      exit(1);
    }

    ($start_port, $stop_port) = split(/\-/, $port_setting);
  } else {
    $start_port = $port_setting;
    $stop_port = $port_setting;
  }
}

if ($start_port <= 1024 or $stop_port <= 1024) {
  print "Privileged ports (equal to or below port 1024) can not be used!\n\n";
  exit(1);
}

if ($start_port > $stop_port) {
  print "First port can not be greater than the last port in a port range!\n\n";
  exit(1);
}

# APPLICATION FOLDER:
my $app_folder = catdir($Bin, 'resources', 'app');

# CUSTOM PATHS:
# Template path:
unshift @{app->renderer->paths}, $app_folder;
# Static files path:
unshift @{app->static->paths}, $app_folder;

# SCRIPTS FINDER:
my @scripts;
if (-d $app_folder) {
  find(sub {
    if (-f $File::Find::name and /.pl$/) {
      push @scripts, $File::Find::name;
    }
  }, $app_folder);
}

if (scalar (@scripts) == 0) {
  print "No Perl scripts are found in the application folder: $app_folder\n\n";
  exit(1);
}

# AVAILABLE PORT FINDER:
unless (defined $no_port_test) {
  my $current_port = $start_port;

  until ($current_port == $stop_port + 1) {
    if (defined $UNSAFE_PORTS{$current_port}) {
      print "Port $current_port is considered an unsafe port.\n";
      print "It may be is used by $UNSAFE_PORTS{$current_port}.\n";
      $current_port++;
    } else {
      my $socket = IO::Socket::INET->
        new(PeerAddr => 'localhost',
            PeerPort => $current_port,
            Proto => 'tcp',
            Timeout => 1);

      if (!$socket) {
        $first_available_port = $current_port;
        last;
      }

      $current_port++;
    }
  }

  if ($first_available_port == 0) {
    if ($start_port < $stop_port) {
      print "No available ports between port $start_port and port $stop_port.\n\n";
    }

    if ($start_port == $stop_port) {
      print "Port $start_port is not available.\n\n";
    }
    exit(1);
  }
}

if (defined $no_port_test) {
  if (defined $UNSAFE_PORTS{$start_port}) {
    print "Port $start_port is considered an unsafe port.\n";
    print "It may be is used by $UNSAFE_PORTS{$start_port}.\n";
    print "Port $start_port is not available.\n\n";
    exit(1);
  } else {
    $first_available_port = $start_port;
  }
}

# BASE ROUTE HANDLER:
# If the local server is contacted from a non-local IP adress,
# it will deny access and it will display a warning page:
any '/' => (
  'access' => [
    {
      on_deny => sub {
        # Tabula gives no response when contacted
        # more than once a second from a non-local IP adress to
        # prevent denial-of-service attacks.
        # Every 3 seconds the forbidden requests counter is restarted.
        $forbidden_requests++;
        if ($forbidden_requests <= 3) {
          my $forbidden_requests_handler = shift;

          $forbidden_requests_handler->res->code(403);
          $forbidden_requests_handler->render(template => 'forbidden');
        }
      }
    },
    allow => 'localhost',
    allow => '127.0.0.1',
    deny  => 'all',
  ]
) => sub {
  my $page_handler = shift;

  $page_closed = 0;
  $page_handler->render('index');
};

# The '/_quit_' URL may be used to signal
# the Tabula server that the local page is closed:
any '/_quit_' => sub {
  $page_closed = 1;
};

# WEBSOCKETS HANDLER:
foreach my $script (@scripts) {
  my($script_name, $script_directory, $script_suffix) =
    fileparse($script, '.pl');

  websocket '/'.$script_name => sub {
    my $websocket_handler = shift;

    $page_closed = 0;

    # No websocket timeout:
    my $loop = Mojo::IOLoop->singleton;
    $loop->stream($websocket_handler->tx->connection)->timeout(0);

    # CHILD PROCESS HANDLER:
    my $child_process = Mojo::IOLoop::ReadWriteFork->new;
    # Make sure the child process object does not go out of scope:
    $websocket_handler->stash(fork => $child_process);

    # Emitted if the child process can not fork:
    $child_process->on(
      error => sub {
        my ($child_process, $child_error) = @_;
        warn $child_error;
      }
    );

    # Emitted when the child prints to STDOUT or STDERR:
    $child_process->on(
      read => sub {
        my ($child_process, $child_process_output) = @_;

        if ($page_closed == 0) {
          $websocket_handler->send(decode('UTF-8', $child_process_output));
        }
      }
    );

    # Start the child process:
    $child_process->start(program => 'perl', program_args => [$script]);
    $running_scripts{$script} = 1;

    # FILESYSTEM HANDLER:
    my $filesystem_handler = Mojo::IOLoop::ReadWriteFork->new;

    # Emitted if the filesystem handler can not fork:
    $filesystem_handler->on(
      error => sub {
        my ($fs_process, $fs_error) = @_;
        warn $fs_error;
      }
    );

    # Emitted when the filesystem handler prints to STDOUT or STDERR:
    $filesystem_handler->on(
      read => sub {
        my ($fs_process, $path) = @_;

        if ($running_scripts{$script} == 1) {
          $child_process->write(encode('UTF-8', $path)."\n");
        } else {
          $child_process->start(program => 'perl', program_args => [$script]);
          $child_process->write(encode('UTF-8', $path)."\n");
          $running_scripts{$script} = 1;
        }
      }
    );

    # Handle websocket requests:
    $websocket_handler->on(
      message => sub {
        my ($websocket, $websocket_request) = @_;

        # Start the filesystem handler:
        if ($websocket_request =~ '_select_') {
          if ($websocket_request =~ '_directory_') {
            $filesystem_handler->run(\&filesystem_selector, "directory");
          }

          if ($websocket_request =~ '_file_') {
            $filesystem_handler->run(\&filesystem_selector, "file");
          }
        } elsif ($websocket_request =~ '_closed_') {
          $running_scripts{$script} = 0;
        } elsif ($websocket_request =~ '_kill_') {
          $child_process->kill();
          $running_scripts{$script} = 0;
        } else {
          if ($running_scripts{$script} == 1) {
            $child_process->write(encode('UTF-8', $websocket_request)."\n");
          } else {
            $child_process->start(program => 'perl', program_args => [$script]);
            $child_process->write(encode('UTF-8', $websocket_request)."\n");
            $running_scripts{$script} = 1;
          }
        }
      }
    );

    # All child processes are closed
    # when the local page and its websockets are closed.
    $websocket_handler->on(
      finish => sub {
        $page_closed = 1;
        $child_process->write('_close_\n');

        Mojo::IOLoop->timer(3 => sub {
          $child_process->kill();
          $running_scripts{$script} = 0;
        });
      }
    );
  };
}

# ADDITIONAL EVENT LOOP:
# The following code is executed every 3 seconds.
my $additional_event_loop = Mojo::IOLoop->recurring(3 => sub {
  # When the local page and all local scripts are closed,
  # the Tabula server is also closed.
  my $active_scripts = 0;
  foreach my $script (keys %running_scripts) {
    $active_scripts = $active_scripts + $running_scripts{$script};
  }

  if ($page_closed == 1 and $active_scripts == 0) {
    print "Closing Tabula local server.\n\n";
    Mojo::IOLoop->stop_gracefully;
  }

  # Forbidden requests counter is restarted:
  $forbidden_requests = 0;
});

# SERVER STARTER:
my $daemon =
  Mojo::Server::Daemon->
    new(app => app, listen => ['http://localhost:'.$first_available_port]);
$daemon->start;

# BROWSER STARTER:
unless ($browser =~ 'none') {
  my $browser_command;

  if ($browser =~ 'default') {
    $browser_command = open_browser_cmd_all();
  } else {
    $browser_command = $browser;
  }

  print "Browser command: $browser_command http://localhost:$first_available_port\n";

  my $pid = fork();
  if (not $pid) {
    close(STDIN) or die "Can not close STDIN: $!";
    close(STDOUT) or die "Can not close STDOUT: $!";
    close(STDERR) or die "Can not close STDERR: $!";

    exec ($browser_command, 'http://localhost:'.$first_available_port);
    exit(0);
  }

  if (not defined $pid) {
    die "Can not fork: $!";
  }
}

# EVENT LOOP STARTER:
Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

# FILE OR FOLDER SELECTION DIALOG:
sub filesystem_selector() {
  my $type = shift;

  my $dialog =
    new UI::Dialog (
      backtitle => 'Tabula', title => 'Tabula',
      height => 20, width => 65, listheight => 5,
      order => ['zenity', 'gdialog', 'xdialog']
    );

  my $path;

  if ($type =~ 'file') {
    $path = $dialog->fselect(path => '/');
  }

  if ($type =~ 'directory') {
    $path = $dialog->dselect(path => '/');
  }

  print $path;
}

# HELP:
sub help {
  print <<HELP;

Author: Dimitar D. Mitov <github.com/ddmitov>
Released under the Artistic License.

Usage:
$0
$0 --browser=<browser> --port=<port> --no-port-test

Optional arguments:
--browser=<browser>
  Possible values:
  1. default - system default browser will be found and used
  2. none - no browser will be started
     This value is useful when Tabula is started by a custom browser application.
  3. full path to a browser binary like:
     /usr/bin/firefox
  4. browser command on PATH like:
     firefox
--port=<port>
  Possible values:
  1. single port number like:
     3000
  2. port range like:
     3000-4000
  Privileged ports equal to or below port 1024 or Chrome unsafe ports
  are not accepted for security reasons!
--no-port-test
  Do not test the supplied single port.
  This option is useful when Tabula is started by a custom browser application.
--help
  this help

If run without arguments, Tabula will operate like started with the command line:
$0 --browser=default --port=3000-9000
The first available port between ports 3000 and 9000 will be used.
Closing the local index page will close the server process too.

HELP
  exit (1);
}

__DATA__

@@ forbidden.html.ep
<!DOCTYPE html>
<html>
  <head>
    <title>Tabula</title>
  </head>
  <body>
    <h1>Access denied!</h1>
  </body>
</html>
